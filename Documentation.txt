URCL++ 2.0 documentation

List of features:
    14 new instructions
    Operand Shorthands: Using fewer operands than those expected by the instruction
                        Using memory values directly on the operands
    Defining new instructions that can be used (that are not part of Main URCL)
    Recursive instructions
    Being able to create and import library functions to be called
    Defining macros to be used on operands
    Defining temporary registers to be ease the translation process of the compiler

List of Future features:
    Being able to provide translations for custom defined instructions
    Translating instructions to its respective translation
    Short circuiting on conditions
    Type system
    Code optimiser for compiler output


New Instructions:
    END: end marks down the end of a code block (similar to '}' character in C like languages). Code blocks start with
        special instructions such as if, switch, while and for loops. On if chains, the code block is separated by elif,
        meaning there is only 1 end keyword for the whole chain, and elif will act as '} else if () {'

    IF: Similar to most programming languages, if the condition is met, it will execute the next code block

    ELIF: Similar to python, if the new condition is met, and the previous conditions on the if chain were false, it
        will execute the next code block

    ELSE: similar to most programming languages, if none of the previous conditions were true, it will execute the next
        code block

    FOR: loops threw the next code block a fixed number of times. The first argument is the starting value, the second
        value is the end, and the third (optional) is the step that is added to the first value at the end of each
        iteration. It evaluates the expression at the start of each iteration, and if the first value is greater or
        equal than the end it will stop.

    WHILE: similar to most programming languages, while the condition is true it will execute the next code block.

    SWITCH: Strictly compares equality between the given value and other pre-defined values on CASE statements. It
        creates a hash table with the hash function: order all the inputs, then offset every one with the value of the
        smallest argument (arg-min(args)). and put them directly on a LUT (DW list). Then check if the entry is inside
         the bounds of the table and get the address of the code to execute. If no DEFAULT statements are defined, the
         default will be to do nothing and just ignores the switch. The unpopulated parts of the list will be programmed
         to the default case.

    CASE: Adds new cases to the current SWITCH statement. The provided cases will be linked to the position of the CASE
        statement inside the SWITCH code block. Note that EXIT are required to stop the next CASE from being executed.

    DEFAULT: Adds a default case to the current SWITCH statement. That default case will be linked with all the empty
        entries on the switch hash table. If no default statement is provided it will be assumed to exist and be empty.
        Note that EXIT are required to stop the next CASE from being executed.

    EXIT: Known as 'break' in most programming languages. It stops executing the current loop or switch statement.

    SKIP: Known as 'continue' in most programming languages. It stops executing the current iteration on a loop, runs
        the final statement, and branches back to the start of the next iteration.

    DEFINE: Defines a macro to be used instead of another operand. That macro is prefixed with '@' character. Can
        replace single word operands, and same macro cannot be reassigned in later parts of the program.

    LCAL:

    TEMP: temp is more of a header than instruction, but it can be used as both. It adds registers to the list of
        registers it can be used during compile-time to translate and simplify code

    INST: Defines how an instruction should work for the compiler. It takes the opcode and all the types of the operands
        that make up the instruction. There are currently 7 types: 'REG', 'IMM', 'WB', 'MEM', 'LOC', 'ANY', 'IO'.
        REG: means it must be a register
        IMM: means it must be a literal value such as an immediate value, char, label (any value known at compile time)
        WB: means it must be a register to be written to
        MEM: TODO


Operand Shorthands:
    Sometimes repetitive information can be omitted, and that is the case for automatic operand completing. Here is an
    example to illustrate how it works: INC R1 R1, it's rare to increment a register to other value other than itself.
    So it would make sense to have INC R1 be valid. But what about 3 operand instructions? Take the example: ADD R1 R1 R2
    In this case we can also omit the repeated source, making it ADD R1 R2.
    Resume: If n-1 operands are presented on an n operand instruction, then the first operand will be repeated on the output code.

    In C you can use * operator to reference the value pointed by a variable. We adopted the [] operator for this matter.
    Inside the [] there can be a value. you can also append [] one after the other to have a pointer of a pointer.
    There are 2 distinct cases: when [] is used to write to, and when [] is used when reading its value.
    When writing, [] cannot be stacked multiple times to extend its logic multiple times.
    Reading:
        ADD R1 R2 R3[R4] will be compiled to
        ADD temp temp R4
        LOD temp temp
        ADD R1 R2 temp

    Writing:
        ADD R1[] R2 R3 will be compiled to
        ADD temp R2 R3
        STR R1 temp

    Note: Currently these 2 features cannot be used at the same time. using [] to write and operand shorthand collides.


Recursive Instructions:
    TODO
